-- ☢️ SCRIPT NUCLEAR DEFINITIVO (ZERO RECURSION - ZERO PROBLEMAS)
-- Este script elimina ABSOLUTAMENTE TODO y lo reconstruye sin posibilidad de recursión.
-- IMPORTANTE: Ejecuta TODO el script de una sola vez en el SQL Editor de Supabase.

-- ========================================
-- FASE 0: PREPARACIÓN
-- ========================================
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- ========================================
-- FASE 1: LIMPIEZA ABSOLUTA
-- ========================================

-- Dropear TODAS las funciones y triggers primero para evitar dependencias
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.check_is_admin() CASCADE;
DROP FUNCTION IF EXISTS public.is_admin() CASCADE;
DROP FUNCTION IF EXISTS public.get_user_role() CASCADE;
DROP FUNCTION IF EXISTS public.admin_delete_user(UUID) CASCADE;
DROP FUNCTION IF EXISTS public.delete_own_account() CASCADE;

-- Dropear tablas con CASCADE para eliminar todas las dependencias
DROP TABLE IF EXISTS public.favorites CASCADE;
DROP TABLE IF EXISTS public.reviews CASCADE;
DROP TABLE IF EXISTS public.leads CASCADE;
DROP TABLE IF EXISTS public.businesses CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- ========================================
-- FASE 2: CREAR TABLAS
-- ========================================

-- PROFILES
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    avatar_url TEXT,
    role TEXT DEFAULT 'user' CHECK (role IN ('admin', 'business_owner', 'user')),
    phone TEXT,
    notifications_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- BUSINESSES
CREATE TABLE public.businesses (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    address TEXT,
    lat NUMERIC,
    lng NUMERIC,
    owner_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    plan_id TEXT DEFAULT 'free',
    is_premium BOOLEAN DEFAULT false,
    is_hidden BOOLEAN DEFAULT false,
    phone TEXT,
    website TEXT,
    group_name TEXT,
    image_url TEXT,
    rating NUMERIC DEFAULT 0,
    review_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- REVIEWS
CREATE TABLE public.reviews (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    business_id BIGINT REFERENCES public.businesses(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    rating INTEGER CHECK (rating >= 1 AND rating <= 5),
    rating_quality INTEGER CHECK (rating_quality >= 1 AND rating <= 5),
    rating_price INTEGER CHECK (rating_price >= 1 AND rating_price <= 5),
    rating_service INTEGER CHECK (rating_service >= 1 AND rating_service <= 5),
    comment TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- FAVORITES
CREATE TABLE public.favorites (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    business_id BIGINT REFERENCES public.businesses(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, business_id)
);

-- LEADS
CREATE TABLE public.leads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    business_name TEXT NOT NULL,
    contact_name TEXT,
    email TEXT,
    phone TEXT,
    category TEXT,
    address TEXT,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'contacted', 'converted', 'rejected')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ========================================
-- FASE 3: POBLAR PROFILES CON DATOS EXISTENTES
-- ========================================
INSERT INTO public.profiles (id, email, full_name, role)
SELECT 
    id, 
    email, 
    COALESCE(raw_user_meta_data->>'full_name', raw_user_meta_data->>'name', 'Usuario'),
    CASE WHEN email = 'fersuko@gmail.com' THEN 'admin' ELSE 'user' END
FROM auth.users
ON CONFLICT (id) DO NOTHING;

-- ========================================
-- FASE 4: HABILITAR RLS
-- ========================================
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.businesses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.leads ENABLE ROW LEVEL SECURITY;

-- ========================================
-- FASE 5: POLÍTICAS RLS (SIN RECURSIÓN - ULTRA SIMPLES)
-- ========================================

-- PROFILES - Lectura pública, modificación propia
CREATE POLICY "profiles_select_public" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "profiles_update_own" ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "profiles_insert_own" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

-- BUSINESSES - Lectura si no está oculto, modificación por owner
-- NO usamos verificación de admin aquí para evitar recursión
CREATE POLICY "businesses_select_visible" ON public.businesses FOR SELECT USING (is_hidden = false);
CREATE POLICY "businesses_insert_authenticated" ON public.businesses FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);
CREATE POLICY "businesses_update_owner" ON public.businesses FOR UPDATE USING (auth.uid() = owner_id);

-- REVIEWS - Público para lectura, autenticado para escritura
CREATE POLICY "reviews_select_all" ON public.reviews FOR SELECT USING (true);
CREATE POLICY "reviews_insert_authenticated" ON public.reviews FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "reviews_update_own" ON public.reviews FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "reviews_delete_own" ON public.reviews FOR DELETE USING (auth.uid() = user_id);

-- FAVORITES - Solo propios
CREATE POLICY "favorites_select_own" ON public.favorites FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "favorites_insert_own" ON public.favorites FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "favorites_delete_own" ON public.favorites FOR DELETE USING (auth.uid() = user_id);

-- LEADS - Solo inserción pública (para formularios)
CREATE POLICY "leads_insert_public" ON public.leads FOR INSERT WITH CHECK (true);

-- ========================================
-- FASE 6: FUNCIONES RPC PARA ADMINS (BYPASS RLS)
-- ========================================

-- RPC: Obtener todos los negocios (incluidos ocultos) - SOLO ADMIN
CREATE OR REPLACE FUNCTION admin_get_all_businesses()
RETURNS SETOF public.businesses AS $$
BEGIN
  -- Verificar que el usuario sea admin
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin') THEN
    RAISE EXCEPTION 'Acceso denegado: Se requiere rol de administrador';
  END IF;
  
  -- Retornar todos los negocios bypasseando RLS
  RETURN QUERY SELECT * FROM public.businesses ORDER BY created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: Obtener todos los usuarios - SOLO ADMIN
CREATE OR REPLACE FUNCTION admin_get_all_users()
RETURNS SETOF public.profiles AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin') THEN
    RAISE EXCEPTION 'Acceso denegado';
  END IF;
  RETURN QUERY SELECT * FROM public.profiles ORDER BY created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: Obtener todos los leads - SOLO ADMIN
CREATE OR REPLACE FUNCTION admin_get_all_leads()
RETURNS SETOF public.leads AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin') THEN
    RAISE EXCEPTION 'Acceso denegado';
  END IF;
  RETURN QUERY SELECT * FROM public.leads ORDER BY created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: Actualizar cualquier negocio - SOLO ADMIN
CREATE OR REPLACE FUNCTION admin_update_business(
  business_id BIGINT,
  updates JSONB
)
RETURNS public.businesses AS $$
DECLARE
  result public.businesses;
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin') THEN
    RAISE EXCEPTION 'Acceso denegado';
  END IF;
  
  UPDATE public.businesses
  SET
    name = COALESCE((updates->>'name')::TEXT, name),
    description = COALESCE((updates->>'description')::TEXT, description),
    category = COALESCE((updates->>'category')::TEXT, category),
    plan_id = COALESCE((updates->>'plan_id')::TEXT, plan_id),
    is_hidden = COALESCE((updates->>'is_hidden')::BOOLEAN, is_hidden),
    is_premium = COALESCE((updates->>'is_premium')::BOOLEAN, is_premium),
    owner_id = COALESCE((updates->>'owner_id')::UUID, owner_id),
    updated_at = NOW()
  WHERE id = business_id
  RETURNING * INTO result;
  
  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: Borrar negocio - SOLO ADMIN
CREATE OR REPLACE FUNCTION admin_delete_business(business_id BIGINT)
RETURNS void AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin') THEN
    RAISE EXCEPTION 'Acceso denegado';
  END IF;
  DELETE FROM public.businesses WHERE id = business_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: Borrar usuario - SOLO ADMIN
CREATE OR REPLACE FUNCTION admin_delete_user(target_user_id UUID)
RETURNS void AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin') THEN
    RAISE EXCEPTION 'Acceso denegado';
  END IF;
  DELETE FROM auth.users WHERE id = target_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: Actualizar rol de usuario - SOLO ADMIN
CREATE OR REPLACE FUNCTION admin_update_user_role(target_user_id UUID, new_role TEXT)
RETURNS void AS $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin') THEN
    RAISE EXCEPTION 'Acceso denegado';
  END IF;
  UPDATE public.profiles SET role = new_role WHERE id = target_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RPC: Obtener rol del usuario actual (Bypass RLS para evitar bloqueos)
CREATE OR REPLACE FUNCTION get_my_role()
RETURNS TEXT AS $$
DECLARE
  v_role TEXT;
BEGIN
  SELECT role INTO v_role FROM public.profiles WHERE id = auth.uid();
  RETURN v_role;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ========================================
-- FASE 7: TRIGGER PARA NUEVOS USUARIOS
-- ========================================
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  user_role TEXT;
BEGIN
  -- Determinar rol basado en email
  user_role := CASE 
    WHEN new.email IN ('fersuko@gmail.com', 'directoriozona@gmail.com') THEN 'admin'
    ELSE 'user'
  END;
  
  INSERT INTO public.profiles (id, email, full_name, avatar_url, role)
  VALUES (
    new.id,
    new.email,
    COALESCE(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name', 'Usuario'),
    new.raw_user_meta_data->>'avatar_url',
    user_role
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    full_name = COALESCE(EXCLUDED.full_name, profiles.full_name),
    avatar_url = COALESCE(EXCLUDED.avatar_url, profiles.avatar_url),
    role = CASE WHEN new.email IN ('fersuko@gmail.com', 'directoriozona@gmail.com') THEN 'admin' ELSE profiles.role END;
    
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- ========================================
-- FASE 8: CREAR SUPER-ADMIN
-- ========================================
DO $$
DECLARE
  v_user_id UUID;
  v_email TEXT := 'directoriozona@gmail.com';
  v_pass TEXT := 'Clavedirectoriozona1.';
BEGIN
  -- Cleanup: Eliminar el usuario incorrecto si existe
  DELETE FROM auth.users WHERE email = 'directoriozonaadmin@gmail.com';
  DELETE FROM public.profiles WHERE email = 'directoriozonaadmin@gmail.com';

  SELECT id INTO v_user_id FROM auth.users WHERE email = v_email;

  IF v_user_id IS NULL THEN
    -- Crear nuevo usuario
    INSERT INTO auth.users (
      id, email, encrypted_password, email_confirmed_at,
      role, aud, confirmation_token, 
      raw_app_meta_data, raw_user_meta_data
    )
    VALUES (
      gen_random_uuid(), v_email, crypt(v_pass, gen_salt('bf')), NOW(),
      'authenticated', 'authenticated', '',
      '{"provider":"email","providers":["email"]}', 
      '{"full_name":"Admin Directorio Zona"}'
    )
    RETURNING id INTO v_user_id;
    
    RAISE NOTICE 'Usuario % creado exitosamente', v_email;
  ELSE
    -- Actualizar contraseña del usuario existente
    UPDATE auth.users 
    SET 
      encrypted_password = crypt(v_pass, gen_salt('bf')),
      email_confirmed_at = COALESCE(email_confirmed_at, NOW())
    WHERE id = v_user_id;
    
    RAISE NOTICE 'Contraseña de % actualizada', v_email;
  END IF;

  -- Asegurar que tenga rol admin en profiles
  INSERT INTO public.profiles (id, email, full_name, role)
  VALUES (v_user_id, v_email, 'Admin Directorio Zona', 'admin')
  ON CONFLICT (id) DO UPDATE SET role = 'admin', full_name = 'Admin Directorio Zona';
  
  RAISE NOTICE 'Perfil admin configurado correctamente';
  RAISE NOTICE 'Perfil admin configurado correctamente';
END $$;

-- ========================================
-- FASE 9: ASEGURAR FERSUKO TAMBIÉN ES ADMIN (DUAL ACCESS)
-- ========================================
DO $$
DECLARE
  v_user_id UUID;
  v_email TEXT := 'fersuko@gmail.com';
  v_pass TEXT := 'Clavedirectoriozona1.';
BEGIN
  SELECT id INTO v_user_id FROM auth.users WHERE email = v_email;

  IF v_user_id IS NULL THEN
    INSERT INTO auth.users (
      id, email, encrypted_password, email_confirmed_at,
      role, aud, confirmation_token, 
      raw_app_meta_data, raw_user_meta_data
    )
    VALUES (
      gen_random_uuid(), v_email, crypt(v_pass, gen_salt('bf')), NOW(),
      'authenticated', 'authenticated', '',
      '{"provider":"email","providers":["email"]}', 
      '{"full_name":"Fersuko Admin"}'
    )
    RETURNING id INTO v_user_id;
  ELSE
    UPDATE auth.users 
    SET 
      encrypted_password = crypt(v_pass, gen_salt('bf')),
      email_confirmed_at = COALESCE(email_confirmed_at, NOW())
    WHERE id = v_user_id;
  END IF;

  INSERT INTO public.profiles (id, email, full_name, role)
  VALUES (v_user_id, v_email, 'Fersuko Admin', 'admin')
  ON CONFLICT (id) DO UPDATE SET role = 'admin';
END $$;

-- ========================================
-- VERIFICACIÓN FINAL
-- ========================================
SELECT '✅ BASE DE DATOS RESETEADA - Admin Access para: fersuko@gmail.com Y directoriozona@gmail.com' as status;
