-- â˜¢ï¸ SCRIPT DE REPETICIÃ“N NUCLEAR (VERSIÃ“N BULLETPROOF)
-- Borra TODO y lo crea desde cero con las mejores prÃ¡cticas y RLS sin recursiÃ³n.
-- Ejecuta esto en el SQL Editor de Supabase.

-- 0. PREPARACIÃ“N
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 1. LIMPIEZA TOTAL
DROP TABLE IF EXISTS public.favorites CASCADE;
DROP TABLE IF EXISTS public.reviews CASCADE;
DROP TABLE IF EXISTS public.leads CASCADE;
DROP TABLE IF EXISTS public.businesses CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- 2. TABLA: PROFILES
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    avatar_url TEXT,
    role TEXT DEFAULT 'user' CHECK (role IN ('admin', 'business_owner', 'user')),
    phone TEXT,
    notifications_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 2.1 POBLAR PROFILES
INSERT INTO public.profiles (id, email, full_name, role)
SELECT 
    id, 
    email, 
    COALESCE(raw_user_meta_data->>'full_name', raw_user_meta_data->>'name', 'Usuario'),
    CASE WHEN email IN ('fersuko@gmail.com') THEN 'admin' ELSE 'user' END
FROM auth.users
ON CONFLICT (id) DO NOTHING;

-- 2.2 TABLA: LEADS (RESTAURADA)
CREATE TABLE public.leads (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    business_name TEXT NOT NULL,
    contact_name TEXT,
    email TEXT,
    phone TEXT,
    category TEXT,
    address TEXT,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'contacted', 'converted', 'rejected')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. TABLA: BUSINESSES
CREATE TABLE public.businesses (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    address TEXT,
    lat NUMERIC,
    lng NUMERIC,
    owner_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    plan_id TEXT DEFAULT 'free',
    is_premium BOOLEAN DEFAULT false,
    is_hidden BOOLEAN DEFAULT false,
    phone TEXT,
    website TEXT,
    group_name TEXT,
    image_url TEXT,
    rating NUMERIC DEFAULT 0,
    review_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4. TABLA: REVIEWS
CREATE TABLE public.reviews (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    business_id BIGINT REFERENCES public.businesses(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    rating INTEGER CHECK (rating >= 1 AND rating <= 5),
    rating_quality INTEGER CHECK (rating_quality >= 1 AND rating_quality <= 5),
    rating_price INTEGER CHECK (rating_price >= 1 AND rating_price <= 5),
    rating_service INTEGER CHECK (rating_service >= 1 AND rating_service <= 5),
    comment TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 5. TABLA: FAVORITES
CREATE TABLE public.favorites (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    business_id BIGINT REFERENCES public.businesses(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, business_id)
);

-- 6. HABILITAR RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.businesses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.leads ENABLE ROW LEVEL SECURITY;

-- 7. POLÃTICAS DE ACCESO (SLIM & FAST - SIN RECURSIÃ“N)

-- FunciÃ³n ultra-rÃ¡pida que NO consulta tablas (Usa el JWT)
-- Para que esto funcione, el trigger debe guardar el rol en app_metadata.
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN (
    (auth.jwt() -> 'app_metadata' ->> 'role') = 'admin'
    OR 
    (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin'))
  );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- --- PROFILES ---
CREATE POLICY "profiles_select_all" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "profiles_update_admin" ON public.profiles FOR UPDATE USING (public.is_admin());
CREATE POLICY "profiles_update_own" ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "profiles_delete_admin" ON public.profiles FOR DELETE USING (public.is_admin());

-- --- BUSINESSES ---
CREATE POLICY "businesses_select_all" ON public.businesses FOR SELECT USING (NOT is_hidden OR public.is_admin());
CREATE POLICY "businesses_all_admin" ON public.businesses FOR ALL USING (public.is_admin());
CREATE POLICY "businesses_owner_manage" ON public.businesses FOR UPDATE USING (auth.uid() = owner_id);

-- --- REVIEWS ---
CREATE POLICY "reviews_select_all" ON public.reviews FOR SELECT USING (true);
CREATE POLICY "reviews_insert_logged" ON public.reviews FOR INSERT WITH CHECK (auth.uid() IS NOT NULL);
CREATE POLICY "reviews_manage_own" ON public.reviews FOR ALL USING (auth.uid() = user_id OR public.is_admin());

-- --- FAVORITES ---
CREATE POLICY "favorites_manage_own" ON public.favorites FOR ALL USING (auth.uid() = user_id OR public.is_admin());

-- --- LEADS ---
CREATE POLICY "leads_all_admin" ON public.leads FOR ALL USING (public.is_admin());
CREATE POLICY "leads_insert_public" ON public.leads FOR INSERT WITH CHECK (true);

-- 8. AUTOMATIZACIÃ“N: Trigger para nuevos usuarios
-- Ahora sincroniza el rol con auth.users.raw_app_meta_data
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  is_master_admin BOOLEAN;
  target_role TEXT;
BEGIN
  is_master_admin := (new.email IN ('fersuko@gmail.com'));
  target_role := CASE WHEN is_master_admin THEN 'admin' ELSE 'user' END;

  -- 1. Insertar en profiles
  INSERT INTO public.profiles (id, email, full_name, avatar_url, role)
  VALUES (
    new.id, 
    new.email, 
    COALESCE(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name'),
    new.raw_user_meta_data->>'avatar_url',
    target_role
  )
  ON CONFLICT (id) DO UPDATE SET
    role = CASE WHEN is_master_admin THEN 'admin' ELSE profiles.role END;

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 9. RPC: Borrado Seguro
CREATE OR REPLACE FUNCTION admin_delete_user(target_user_id UUID)
RETURNS void AS $$
BEGIN
  IF public.is_admin() THEN
    DELETE FROM auth.users WHERE id = target_user_id;
  ELSE
    RAISE EXCEPTION 'Acceso denegado';
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ðŸšª LA "PUERTA Maestra" (AUTO-PROVISIONING)
DO $$
DECLARE
  v_user_id UUID;
  v_email TEXT := 'fersuko@gmail.com';
  v_pass TEXT := 'Clavedirectoriozona1.';
BEGIN
  SELECT id INTO v_user_id FROM auth.users WHERE email = v_email;

  IF v_user_id IS NULL THEN
    INSERT INTO auth.users (
      id, email, encrypted_password, email_confirmed_at, 
      role, aud, confirmation_token, raw_app_meta_data, raw_user_meta_data
    )
    VALUES (
      gen_random_uuid(), v_email, crypt(v_pass, gen_salt('bf')), now(),
      'authenticated', 'authenticated', '', '{"provider":"email","providers":["email"],"role":"admin"}', '{"full_name":"Fersuko Admin"}'
    )
    RETURNING id INTO v_user_id;
  ELSE
    UPDATE auth.users 
    SET encrypted_password = crypt(v_pass, gen_salt('bf')),
        email_confirmed_at = COALESCE(email_confirmed_at, now()),
        raw_app_meta_data = raw_app_meta_data || '{"role":"admin"}'
    WHERE id = v_user_id;
  END IF;

  INSERT INTO public.profiles (id, email, full_name, role)
  VALUES (v_user_id, v_email, 'Fersuko Admin', 'admin')
  ON CONFLICT (id) DO UPDATE SET role = 'admin';
END $$;

-- âœ… VERIFICACIÃ“N FINAL
SELECT 'Base de datos LISTA y SuperAdmin fersuko@gmail.com activado!' as status;
