-- â˜¢ï¸ SCRIPT DE REPETICIÃ“N NUCLEAR (LIMPIEZA TOTAL Y REESTRUCTURA)
-- Borra TODO y lo crea desde cero con las mejores prÃ¡cticas.
-- Ejecuta esto en el SQL Editor de Supabase.

-- 0. PREPARACIÃ“N
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 1. LIMPIEZA TOTAL (Orden jerÃ¡rquico para evitar errores de llave forÃ¡nea)
DROP TABLE IF EXISTS public.favorites CASCADE;
DROP TABLE IF EXISTS public.reviews CASCADE;
DROP TABLE IF EXISTS public.leads CASCADE;
DROP TABLE IF EXISTS public.businesses CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- 2. TABLA: PROFILES (Identidad Unificada)
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    avatar_url TEXT,
    role TEXT DEFAULT 'user' CHECK (role IN ('admin', 'business_owner', 'user')),
    phone TEXT,
    notifications_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 2.1 POBLAR PROFILES (Para usuarios que ya existen en Supabase)
-- Esto evita que usuarios viejos sean "fantasmas" y no puedan entrar.
INSERT INTO public.profiles (id, email, full_name, role)
SELECT 
    id, 
    email, 
    COALESCE(raw_user_meta_data->>'full_name', raw_user_meta_data->>'name', 'Usuario'),
    CASE WHEN email IN ('fersuko@gmail.com') THEN 'admin' ELSE 'user' END
FROM auth.users
ON CONFLICT (id) DO NOTHING;

-- 3. TABLA: BUSINESSES (BIGINT y Robustez)
CREATE TABLE public.businesses (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, -- Autoincrementable o manual
    name TEXT NOT NULL,
    description TEXT,
    category TEXT,
    address TEXT,
    lat NUMERIC,
    lng NUMERIC,
    owner_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    plan_id TEXT DEFAULT 'free',
    is_premium BOOLEAN DEFAULT false,
    is_hidden BOOLEAN DEFAULT false,
    phone TEXT,
    website TEXT,
    group_name TEXT,
    image_url TEXT,
    rating NUMERIC DEFAULT 0,
    review_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4. TABLA: REVIEWS (Multi-mÃ©trica)
CREATE TABLE public.reviews (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    business_id BIGINT REFERENCES public.businesses(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    rating INTEGER CHECK (rating >= 1 AND rating <= 5),
    rating_quality INTEGER CHECK (rating_quality >= 1 AND rating_quality <= 5),
    rating_price INTEGER CHECK (rating_price >= 1 AND rating_price <= 5),
    rating_service INTEGER CHECK (rating_service >= 1 AND rating_service <= 5),
    comment TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 5. TABLA: FAVORITES
CREATE TABLE public.favorites (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    business_id BIGINT REFERENCES public.businesses(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, business_id)
);

-- 6. HABILITAR RLS (Seguridad)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.businesses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;

-- 7. POLÃTICAS DE ACCESO (Simples y Efectivas)

-- FunciÃ³n de seguridad para evitar recursiÃ³n infinita
-- Al ser SECURITY DEFINER, permite consultar la tabla profiles sin disparar RLS recursivos.
CREATE OR REPLACE FUNCTION public.check_is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  -- Usamos SELECT 1 para ser eficientes
  RETURN EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- --- POLÃTICAS PARA PROFILES ---
CREATE POLICY "Profiles SELECT: Public" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Profiles INSERT: Own" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Profiles UPDATE: Own or Admin" ON public.profiles FOR UPDATE USING (auth.uid() = id OR public.check_is_admin());
CREATE POLICY "Profiles DELETE: Admin Only" ON public.profiles FOR DELETE USING (public.check_is_admin());

-- --- POLÃTICAS PARA BUSINESSES ---
CREATE POLICY "Businesses SELECT: Public and Non-Hidden" ON public.businesses FOR SELECT USING (NOT is_hidden OR public.check_is_admin());
CREATE POLICY "Businesses INSERT: Owners or Admin" ON public.businesses FOR INSERT WITH CHECK (auth.uid() = owner_id OR public.check_is_admin());
CREATE POLICY "Businesses UPDATE: Owners or Admin" ON public.businesses FOR UPDATE USING (auth.uid() = owner_id OR public.check_is_admin());
CREATE POLICY "Businesses DELETE: Admin Only" ON public.businesses FOR DELETE USING (public.check_is_admin());

-- --- POLÃTICAS PARA REVIEWS ---
CREATE POLICY "Reviews SELECT: Public" ON public.reviews FOR SELECT USING (true);
CREATE POLICY "Reviews INSERT: Authenticated" ON public.reviews FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Reviews UPDATE: Own or Admin" ON public.reviews FOR UPDATE USING (auth.uid() = user_id OR public.check_is_admin());
CREATE POLICY "Reviews DELETE: Own or Admin" ON public.reviews FOR DELETE USING (auth.uid() = user_id OR public.check_is_admin());

-- --- POLÃTICAS PARA FAVORITES ---
CREATE POLICY "Favorites SELECT: Own or Admin" ON public.favorites FOR SELECT USING (auth.uid() = user_id OR public.check_is_admin());
CREATE POLICY "Favorites INSERT: Own" ON public.favorites FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Favorites DELETE: Own" ON public.favorites FOR DELETE USING (auth.uid() = user_id);

-- 8. AUTOMATIZACIÃ“N: Trigger para nuevos usuarios
-- Incluye Puerta Maestra y "Primer Usuario = Admin"
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  is_master_admin BOOLEAN;
  any_admin_exists BOOLEAN;
BEGIN
  -- 1. Verificar si el correo estÃ¡ en la lista blanca
  is_master_admin := (new.email IN ('fersuko@gmail.com', 'tu_correo_real@ejemplo.com'));

  -- 2. Verificar si ya existe algÃºn admin en el sistema
  SELECT EXISTS (SELECT 1 FROM public.profiles WHERE role = 'admin') INTO any_admin_exists;

  INSERT INTO public.profiles (id, email, full_name, avatar_url, role)
  VALUES (
    new.id, 
    new.email, 
    COALESCE(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name'),
    new.raw_user_meta_data->>'avatar_url',
    -- Si es master admin O si es el primer usuario del sistema, hacerlo admin
    CASE WHEN is_master_admin OR NOT any_admin_exists THEN 'admin' ELSE 'user' END
  )
  ON CONFLICT (id) DO UPDATE SET
    email = EXCLUDED.email,
    full_name = COALESCE(EXCLUDED.full_name, profiles.full_name),
    avatar_url = COALESCE(EXCLUDED.avatar_url, profiles.avatar_url),
    -- Re-evaluar rol en el update si es master admin
    role = CASE WHEN is_master_admin THEN 'admin' ELSE profiles.role END;
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 9. RPC: Borrado Seguro
-- Borrar mi propia cuenta
CREATE OR REPLACE FUNCTION delete_own_account()
RETURNS void AS $$
BEGIN
  DELETE FROM auth.users WHERE id = auth.uid();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Borrar cualquier usuario (SOLO ADMIND)
CREATE OR REPLACE FUNCTION admin_delete_user(target_user_id UUID)
RETURNS void AS $$
BEGIN
  -- Verificar que el ejecutor es admin
  IF EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND role = 'admin') THEN
    DELETE FROM auth.users WHERE id = target_user_id;
  ELSE
    RAISE EXCEPTION 'Solo los administradores pueden borrar usuarios';
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ðŸšª LA "PUERTA Maestra" (SUPER-ADMIN AUTO-PROVISIONING)
-- Este bloque crea o actualiza tu usuario con la contraseÃ±a que pediste.
DO $$
DECLARE
  v_user_id UUID;
  v_email TEXT := 'fersuko@gmail.com';
  v_pass TEXT := 'Clavedirectoriozona1.';
BEGIN
  -- 1. Intentar obtener el ID si ya existe
  SELECT id INTO v_user_id FROM auth.users WHERE email = v_email;

  IF v_user_id IS NULL THEN
    -- 2. No existe: Crear usuario nuevo
    INSERT INTO auth.users (
      id, email, encrypted_password, email_confirmed_at, 
      role, aud, confirmation_token, raw_app_meta_data, raw_user_meta_data
    )
    VALUES (
      gen_random_uuid(), v_email, crypt(v_pass, gen_salt('bf')), now(),
      'authenticated', 'authenticated', '', '{"provider":"email","providers":["email"]}', '{"full_name":"Fersuko Admin"}'
    )
    RETURNING id INTO v_user_id;
    
    RAISE NOTICE 'Usuario % creado con Ã©xito.', v_email;
  ELSE
    -- 3. Ya existe: Actualizar solo la contraseÃ±a
    UPDATE auth.users 
    SET encrypted_password = crypt(v_pass, gen_salt('bf')),
        email_confirmed_at = COALESCE(email_confirmed_at, now())
    WHERE id = v_user_id;
    
    RAISE NOTICE 'ContraseÃ±a de % actualizada con Ã©xito.', v_email;
  END IF;

  -- 4. Asegurar que estÃ© en profiles con rol admin
  INSERT INTO public.profiles (id, email, full_name, role)
  VALUES (v_user_id, v_email, 'Fersuko Admin', 'admin')
  ON CONFLICT (id) DO UPDATE SET role = 'admin';

END $$;

-- âœ… VERIFICACIÃ“N FINAL
SELECT 'Base de datos reseteada, optimizada y SuperAdmin fersuko@gmail.com listo!' as status;
